<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas合成与裁剪</title>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
    }

    body {
        width: 100vw;
        height: 100vh;
    }

    #canvas {
        border: 1px solid black;
        margin: 200px;
    }
</style>

<body>
    <canvas id="canvas" width="600" height="600"></canvas>
    <canvas id="canvas2" width="600" height="600"></canvas>
</body>
<script>
    /** @type {HTMLCanvasElement} */
    let ctx = document.getElementById("canvas").getContext("2d");
    //学习globalCompositeOperation属性，图像合成。
    function globalCompositeOperationTest() {
        ctx.save();
        ctx.fillStyle = 'rgba(255,0,0,0.5)';
        ctx.beginPath();
        ctx.arc(80, 80, 80, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
        /* 默认情况下（source-over），后画的图形（目标图形）会覆盖先画的图形（源图形） */
        // ctx.globalCompositeOperation = 'source-in'; //目标图形和源图形重叠且都不透明的部分才被绘制。
        // ctx.globalCompositeOperation = 'source-out'; //目标图形和源图形不重叠的部分会被绘制。
        // ctx.globalCompositeOperation = 'source-atop'; //目标图形和源图形内容重叠的部分+源图形其余部分。
        // ctx.globalCompositeOperation = 'destination-over'; //这个属性很明显和默认值source-over相反，源图形覆盖目标图形。
        // destination-in、destination-out、destination-atop //同理
        ctx.globalCompositeOperation = 'lighter';//?颜色值相加,示例未看出效果
        ctx.globalCompositeOperation = 'copy';//只显示目标图形
        ctx.globalCompositeOperation = 'xor';//重叠部分颜色叠加，其余部分正常显示
        ctx.globalCompositeOperation = 'multiply';//像素相乘，结果是一幅更黑暗的图片
        //还有很多关于颜色变化的取值，就不一一尝试了，个人感觉最有用的还是裁剪的属性，可以组合成一些常见的图案。
        ctx.fillStyle = 'orange';
        ctx.beginPath();
        ctx.arc(120, 120, 80, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    // globalCompositeOperationTest();

    //图像裁剪（基本）
    function clipFun() {
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'red';
        ctx.rect(0, 0, 200, 200);
        ctx.clip();
        /* beginPath后路径就重新计算了，stroke就从当前路径stroke。否则路径就是一直存在的*/
        // ctx.beginPath();  
        ctx.arc(200, 200, 100, (Math.PI / 180) * 0, (Math.PI / 180) * 360, false);
        ctx.stroke();
        ctx.closePath();
    }
    // clipFun();
    //gif的例子
    function clipGif() {
        let dig = Math.PI / 180
        let i = 0
        function draw() {
            ctx.clearRect(0, 0, 600, 600);
            ctx.beginPath();
            /* 角度计算默认是顺时针方向计算的 */
            ctx.arc(350, 350, 200, 0, i * dig);
            ctx.stroke()
            // ctx.lineTo(350, 350);
            // ctx.closePath();
        }
        let timer = setInterval(() => {
            if (i > 360) {
                clearInterval(timer);
                i = 0;
            } else {
                draw();
                i++
            }
        }, 10)
    }
    // clipGif();

    //例子2
    function clipGif2() {
        let count = 0;//计数
        let dig = Math.PI / 20;

        var img = new Image();
        img.src = "./image/bridge.jpg";
        img.onload = (() => {
            setInterval(() => {
                if (count >= -40) {
                    addRadial();
                    count--
                }
            }, 100)
        });
        function addRadial() {
            /* 保存和恢复绘画状态是必须的，否则的画canvas clip效果永远存在。那么第一次clip最小的弧形，就会只显示那么一点点了 */
            ctx.save();//保存当前绘图状态
            ctx.beginPath();//开始创建路径
            console.log('dig==', dig)
            console.log('count', count)
            ctx.arc(250, 250, 150, 0, dig * count, true);
            /* 添加lineTo和closePath让弧形两端和圆点相连，而不是弧的两端点相连。即封闭成一个扇形而不是一个弧形 */
            ctx.lineTo(250, 250);
            ctx.closePath();//关闭路径
            ctx.stroke();
            ctx.clip();
            ctx.drawImage(img, 100, 100, 300, 300);
            ctx.restore();
        }
    }
    clipGif2();
</script>

</html>